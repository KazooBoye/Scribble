#!/usr/bin/env python3
"""
Scribble Game - Pygame Client
UI in Python/Pygame, networking in C (via ctypes)
"""

import pygame
import sys
from network_wrapper import NetworkClient
from protocol import MSG_TYPE, COLORS, get_color

# Initialize Pygame
pygame.init()

# Constants
WINDOW_WIDTH = 1200
WINDOW_HEIGHT = 700
CANVAS_WIDTH = 800
CANVAS_HEIGHT = 600
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (200, 200, 200)
LIGHT_GRAY = (240, 240, 240)
BLUE = (70, 130, 220)
GREEN = (76, 175, 80)
RED = (244, 67, 54)


class DrawingCanvas:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.surface = pygame.Surface((width, height))
        self.surface.fill(WHITE)
        
        self.drawing = False
        self.last_pos = None
        self.color = BLACK
        self.line_width = 3
        self.stroke_id = 0
        
    def handle_mouse_down(self, pos):
        if self.point_in_canvas(pos):
            self.drawing = True
            canvas_pos = (pos[0] - self.x, pos[1] - self.y)
            self.last_pos = canvas_pos
            
    def handle_mouse_up(self, pos):
        self.drawing = False
        self.last_pos = None
        
    def handle_mouse_move(self, pos, network):
        if self.drawing and self.point_in_canvas(pos):
            canvas_pos = (pos[0] - self.x, pos[1] - self.y)
            
            if self.last_pos:
                # Draw locally
                pygame.draw.line(self.surface, self.color, self.last_pos, canvas_pos, self.line_width)
                
                # Send stroke to server (UDP for low latency)
                network.send_udp(MSG_TYPE.DRAW_STROKE, {
                    'stroke_id': self.stroke_id,
                    'x1': self.last_pos[0],
                    'y1': self.last_pos[1],
                    'x2': canvas_pos[0],
                    'y2': canvas_pos[1],
                    'color': self.get_color_index(),
                    'thickness': self.line_width
                })
                self.stroke_id += 1
            
            self.last_pos = canvas_pos
    
    def point_in_canvas(self, pos):
        return (self.x <= pos[0] <= self.x + self.width and
                self.y <= pos[1] <= self.y + self.height)
    
    def draw_stroke(self, x1, y1, x2, y2, color_index, thickness):
        """Draw stroke from server"""
        color = get_color(color_index)
        pygame.draw.line(self.surface, color, (x1, y1), (x2, y2), thickness)
    
    def clear(self):
        self.surface.fill(WHITE)
    
    def set_color(self, color):
        self.color = color
        
    def get_color_index(self):
        """Get index of current color"""
        try:
            return COLORS.index(self.color)
        except ValueError:
            return 0
    
    def render(self, screen):
        # Draw canvas
        screen.blit(self.surface, (self.x, self.y))
        # Draw border
        pygame.draw.rect(screen, GRAY, (self.x, self.y, self.width, self.height), 2)


class ScribbleGame:
    def __init__(self):
        self.screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("Scribble - Drawing & Guessing Game")
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.connected = False
        self.username = "Player"
        self.player_id = None
        self.room_id = None
        self.players = []
        self.chat_messages = []
        self.is_drawer = False
        self.word_to_draw = ""
        self.timer = 0
        
        # UI Components
        self.canvas = DrawingCanvas(20, 80, CANVAS_WIDTH, CANVAS_HEIGHT)
        self.chat_input = ""
        self.status_message = "Connecting to server..."
        
        # Networking (C library via ctypes)
        self.network = NetworkClient()
        self.setup_network_handlers()
        
        # Connect to server
        if self.network.connect():
            self.connected = True
            self.status_message = "Connected! Click 'Play Now' to start"
            # Register player
            self.network.send_tcp(MSG_TYPE.REGISTER, {'username': self.username})
        else:
            self.status_message = "Failed to connect to server"
    
    def setup_network_handlers(self):
        """Register message handlers"""
        self.network.register_handler(MSG_TYPE.REGISTER_ACK, self.handle_register_ack)
        self.network.register_handler(MSG_TYPE.ROOM_JOINED, self.handle_room_joined)
        self.network.register_handler(MSG_TYPE.GAME_START, self.handle_game_start)
        self.network.register_handler(MSG_TYPE.ROUND_START, self.handle_round_start)
        self.network.register_handler(MSG_TYPE.WORD_TO_DRAW, self.handle_word_to_draw)
        self.network.register_handler(MSG_TYPE.CHAT_BROADCAST, self.handle_chat)
        self.network.register_handler(MSG_TYPE.DRAW_BROADCAST, self.handle_draw_stroke)
        self.network.register_handler(MSG_TYPE.TIMER_UPDATE, self.handle_timer)
        self.network.register_handler(MSG_TYPE.PLAYER_JOINED, self.handle_player_joined)
        self.network.register_handler(MSG_TYPE.ROUND_END, self.handle_round_end)
    
    # Network message handlers
    def handle_register_ack(self, data):
        self.player_id = data.get('player_id')
        self.username = data.get('username', self.username)
        print(f"[Game] Registered as {self.username} (ID: {self.player_id})")
    
    def handle_room_joined(self, data):
        self.room_id = data.get('room_id')
        self.players = data.get('players', [])
        self.status_message = f"Joined room: {self.room_id}"
        print(f"[Game] Joined room {self.room_id}")
    
    def handle_game_start(self, data):
        self.status_message = "Game starting!"
        self.canvas.clear()
        print("[Game] Game started")
    
    def handle_round_start(self, data):
        drawer_id = data.get('drawer_id')
        self.is_drawer = (drawer_id == self.player_id)
        self.status_message = "You are drawing!" if self.is_drawer else "Guess the word!"
        print(f"[Game] Round started, drawer: {drawer_id}")
    
    def handle_word_to_draw(self, data):
        self.word_to_draw = data.get('word', '')
        self.status_message = f"Draw: {self.word_to_draw}"
        print(f"[Game] Word to draw: {self.word_to_draw}")
    
    def handle_chat(self, data):
        username = data.get('username', 'Unknown')
        message = data.get('message', '')
        self.chat_messages.append(f"{username}: {message}")
        if len(self.chat_messages) > 10:
            self.chat_messages.pop(0)
    
    def handle_draw_stroke(self, data):
        # Draw stroke from other players
        x1 = data.get('x1', 0)
        y1 = data.get('y1', 0)
        x2 = data.get('x2', 0)
        y2 = data.get('y2', 0)
        color_idx = data.get('color', 0)
        thickness = data.get('thickness', 3)
        
        self.canvas.draw_stroke(x1, y1, x2, y2, color_idx, thickness)
    
    def handle_timer(self, data):
        self.timer = data.get('time_left', 0)
    
    def handle_player_joined(self, data):
        player = data.get('player')
        if player and player not in self.players:
            self.players.append(player)
    
    def handle_round_end(self, data):
        word = data.get('word', '')
        self.status_message = f"Round ended! Word was: {word}"
        self.word_to_draw = ""
    
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left click
                    self.canvas.handle_mouse_down(event.pos)
                    self.handle_ui_click(event.pos)
            
            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    self.canvas.handle_mouse_up(event.pos)
            
            elif event.type == pygame.MOUSEMOTION:
                self.canvas.handle_mouse_move(event.pos, self.network)
            
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    self.send_chat()
                elif event.key == pygame.K_BACKSPACE:
                    self.chat_input = self.chat_input[:-1]
                else:
                    if event.unicode.isprintable():
                        self.chat_input += event.unicode
    
    def handle_ui_click(self, pos):
        # Play Now button (simple implementation)
        if 850 < pos[0] < 1150 and 100 < pos[1] < 150:
            if self.connected:
                self.network.send_tcp(MSG_TYPE.QUICK_MATCH, {})
                self.status_message = "Looking for game..."
        
        # Color palette clicks
        for i, color in enumerate(COLORS):
            color_x = 850 + (i % 5) * 50
            color_y = 200 + (i // 5) * 50
            if color_x < pos[0] < color_x + 40 and color_y < pos[1] < color_y + 40:
                self.canvas.set_color(color)
                break
    
    def send_chat(self):
        if self.chat_input and self.connected:
            self.network.send_tcp(MSG_TYPE.CHAT_MESSAGE, {'message': self.chat_input})
            self.chat_input = ""
    
    def render(self):
        self.screen.fill(LIGHT_GRAY)
        
        # Draw canvas
        self.canvas.render(self.screen)
        
        # Draw UI
        self.render_sidebar()
        self.render_status()
        self.render_chat()
        
        pygame.display.flip()
    
    def render_sidebar(self):
        # Right sidebar
        font = pygame.font.Font(None, 28)
        
        # Title
        title = font.render("Scribble", True, BLACK)
        self.screen.blit(title, (950, 20))
        
        # Play Now button
        if self.connected:
            pygame.draw.rect(self.screen, GREEN, (850, 100, 300, 50))
            btn_text = font.render("Play Now", True, WHITE)
            self.screen.blit(btn_text, (920, 115))
        
        # Color Palette
        label = font.render("Colors:", True, BLACK)
        self.screen.blit(label, (850, 170))
        
        for i, color in enumerate(COLORS):
            x = 850 + (i % 5) * 50
            y = 200 + (i // 5) * 50
            pygame.draw.rect(self.screen, color, (x, y, 40, 40))
            pygame.draw.rect(self.screen, GRAY, (x, y, 40, 40), 2)
        
        # Players
        label = font.render("Players:", True, BLACK)
        self.screen.blit(label, (850, 320))
        
        small_font = pygame.font.Font(None, 22)
        for i, player in enumerate(self.players[:8]):
            username = player.get('username', 'Unknown')
            score = player.get('score', 0)
            text = small_font.render(f"{username}: {score}", True, BLACK)
            self.screen.blit(text, (850, 350 + i * 25))
    
    def render_status(self):
        font = pygame.font.Font(None, 24)
        
        # Status message
        status = font.render(self.status_message, True, BLACK)
        self.screen.blit(status, (30, 20))
        
        # Timer
        if self.timer > 0:
            timer_text = font.render(f"Time: {self.timer}s", True, RED)
            self.screen.blit(timer_text, (CANVAS_WIDTH - 100, 20))
        
        # Word to draw
        if self.word_to_draw:
            word_font = pygame.font.Font(None, 36)
            word = word_font.render(self.word_to_draw, True, BLUE)
            self.screen.blit(word, (30, 50))
    
    def render_chat(self):
        # Chat area
        chat_y = CANVAS_HEIGHT + 100
        pygame.draw.rect(self.screen, WHITE, (20, chat_y, CANVAS_WIDTH, 80))
        pygame.draw.rect(self.screen, GRAY, (20, chat_y, CANVAS_WIDTH, 80), 2)
        
        font = pygame.font.Font(None, 20)
        
        # Chat messages
        for i, msg in enumerate(self.chat_messages[-3:]):
            text = font.render(msg, True, BLACK)
            self.screen.blit(text, (30, chat_y + 5 + i * 20))
        
        # Chat input
        input_text = font.render(f"> {self.chat_input}_", True, BLACK)
        self.screen.blit(input_text, (30, chat_y + 60))
    
    def run(self):
        while self.running:
            self.handle_events()
            self.render()
            self.clock.tick(FPS)
        
        # Cleanup
        self.network.disconnect()
        pygame.quit()
        sys.exit()


if __name__ == '__main__':
    game = ScribbleGame()
    game.run()
